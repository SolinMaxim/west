5. «Гатлинг»
Нехорошо нападать на мирных жителей. Это еще может быть опасно, если в сарае припрятан Гатлинг.

Добавь карту `Gatling`:
- называется Гатлинг, сила 6, наследуется от `Creature`.
- при атаке наносит 2 урона по очереди всем картам противника на столе, но не атакует игрока-противника.
  Таким образом урон сначала получает самая левая карта противника, затем вторая слева и так далее.
  Урон не должен наноситься одновременно.

Подсказки:
- переопредели метод `attack` так, чтобы урон наносился всем картам противника
- список карт противника можно получить через `gameContext.oppositePlayer.table`
- в качестве примера выполнения действий над несколькими картами можешь использовать `applyCards` из `Player.js`

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Duck(),
    new Duck(),
    new Gatling(),
];
const banditStartDeck = [
    new Trasher(),
    new Dog(),
    new Dog(),
];
```


6. «Братки»
Чем их больше, тем они сильнее.

Добавь карту `Lad`:
- называется Браток, сила 2, наследуется от `Dog`.
- чем больше братков находится в игре, тем больше урона без потерь поглощается
  и больше урона по картам наносится каждым из них.

Защита от урона      =  количество * (количество + 1) / 2
Дополнительный урон  =  количество * (количество + 1) / 2

Подсказки:
- текущее количество братков в игре надо где-то хранить, свойство в функции-конструкторе `Lad` — подходящее место.
  Заведи для этого пару методов:
    `static getInGameCount() { return this.inGameCount || 0; }`
    `static setInGameCount(value) { this.inGameCount = value; }`
  Хоть свойство `inGameCount` в функции `Lad`, другими словами статическое свойство класса `Lad`, явно не объявляется,
  при первом вызове `setInGameCount`, оно будет создано со значением `value`.
- чтобы обновлять количество братков в игре переопредели методы `doAfterComingIntoPlay`, `doBeforeRemoving`
- чтобы рассчитывать бонус к урону и защите стоит завести статический метод в классе `Lad`.
  Выглядеть будет как-то так: `static getBonus() { ... }`
  Чтобы в `getBonus` обращаться к другим статическим методам используй `this`, а не имя класса `Lad`.
  Вспомни, почему в статических методах в качестве `this` передается `Lad`.
- переопредели методы `modifyDealedDamageToCreature` и `modifyTakenDamage`, чтобы они использовали бонус.

Добавь в описание карты «Чем их больше, тем они сильнее».
Этот текст должен появляться только если непосредственно у братков (т.е. в `Lad.prototype`)
переопределены методы `modifyDealedDamageToCreature` или `modifyTakenDamage`.
Проверка на наличие свойства непосредственно у объекта выполняется с помщью метода `hasOwnProperty`.
Проверка наличия метода `modifyDealedDamageToCreature` у братков выглядит так:
    `Lad.prototype.hasOwnProperty('modifyDealedDamageToCreature')`
Эта особенность понадобится на следующем шаге.
Как видишь, даже при использовании `class` весь функционал прототипов доступен и работает.

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Duck(),
    new Duck(),
];
const banditStartDeck = [
    new Lad(),
    new Lad(),
];
```


7*. «Изгой»
От него все бегут, потому что он приходит и отнимает силы...

Добавь карту `Rogue`:
- называется Изгой, сила 2, наследуется от `Creature`.
- перед атакой на карту забирает у нее все способности к увеличению наносимого урона или уменьшению получаемого урона.
  Одновременно эти способности забираются у всех карт того же типа, но не у других типов карт.
  Изгой получает эти способности, но не передает их другим Изгоям.

Подсказки:
- Изгой похищает эти способности: `modifyDealedDamageToCreature`, `modifyDealedDamageToPlayer`, `modifyTakenDamage`
- Чтобы похитить способности у всех карт некоторого типа, надо взять их из прототипа
- Получить доступ к прототипу некоторой карты можно так: `Object.getPrototypeOf(card)`
- Чтобы не похищать способности у других типов, нельзя задевать прототип прототипа
- `Object.getOwnPropertyNames` и `obj.hasOwnProperty` позволяют получать только собственные свойства объекта
- Удалить свойство из объекта можно с помощью оператора `delete` так: `delete obj[propName]`
  Это не то же самое, что `obj[propName] = undefined`
- После похищения стоит обновить вид всех объектов игры. `updateView` из `gameContext` поможет это сделать.

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Duck(),
    new Duck(),
    new Rogue(),
];
const banditStartDeck = [
    new Lad(),
    new Lad(),
    new Lad(),
];
```


8*. «Пивовар»
Живительное пиво помогает уткам творить невозможное!

Добавь карту `Brewer`:
- называется Пивовар, сила 2, наследуется от `Duck`.
- перед атакой на карту Пивовар раздает пиво,
  которое изменяет максимальную силу карты на +1, а затем текущую силу на +2.
- Пивовар угощает пивом все карты на столе: и текущего игрока и игрока-противника,
но только с утками, проверяя их с помощью `isDuck`.
- Пивовар само собой утка, поэтому его сила тоже возврастает.

Подсказки:
- Все карты на столе можно получить из `gameContext` так: `currentPlayer.table.concat(oppositePlayer.table)`.
- `this.view.signalHeal` — используй, чтобы подсветить карту, у которой увеличилась сила.
- `card.updateView()` — используй, чтобы обновлять вид карт, у которых увеличилась сила.

Важно, чтобы при увеличении текущей силы она не превышала максимальную.
Добиться этого можно по разному, но решить этот вопрос раз и навсегда иначе определив свойство `currentPower` в `Card`.

Сейчас оно определяется в конструкторе `Card` довольно просто:
    `this.currentPower = maxPower`
Пусть так и определяется.

А вот в `Creature` определи заново свойство `currentPower` через `get` и `set`.
Геттер должен просто возвращать текущее значение, а сеттер не давать устанавливать значение выше, чем `this.maxPower`.

Подробнее про `get` и `set` тут:
  https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/get
  https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/set

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Brewer(),
];
const banditStartDeck = [
    new Dog(),
    new Dog(),
    new Dog(),
    new Dog(),
];
```


9*. «Псевдоутка»
Чтобы получить доступ к живительному напитку надо всего лишь
выглядеть как утка, плавать как утка и крякать как утка!

Добавь карту `PseudoDuck`:
- называется Псевдоутка, сила 3, наследуется от `Dog`.
- Псевдоутка — это обычный пес, но еще умеет крякать и плавать, поэтому легко проходит проверку на утиность `isDuck`.

Подсказки:
- чтобы быть похожим на утку надо всего лишь реализовывать пару методов: `quacks` и `swims`
- убедись, что в описании Псевдоутки присутстует «Утка-Собака».

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Brewer(),
];
const banditStartDeck = [
    new Dog(),
    new PseudoDuck(),
    new Dog(),
];
```


10*. «Немо»
«The one without a name without an honest heart as compass»

Добавь карту `Nemo`:
- называется Немо, сила 4, наследуется от `Creature`.
- перед атакой на карту крадет ее прототип и назначает себе, получая все ее способности,
  но вместе со своим старым прототипом теряет способность красть.
- если карта, у которой был украден прототип, обладает способностями, выполняющимися перед атакой,
  то они должны быть выполнены сразу после кражи прототипа.

Подсказки:
- `updateView` из `gameContext` позволяет обновить вид всех объектов игры.
- `Object.getPrototypeOf(obj)` позволяет получить прототип объекта.
- `Object.setPrototypeOf(obj, proto)` позволяет задать протип объекту.
- функция `doBeforeAttack` из прототипа должна быть вызвана сразу после кражи прототипа.

Колоды для проверки:
```js
const seriffStartDeck = [
    new Nemo(),
];
const banditStartDeck = [
    new Brewer(),
    new Brewer(),
];
```
